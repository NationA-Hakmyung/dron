<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Drone Formation Animation</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
      }
      canvas {
        display: block;
      }
    </style>
  </head>
  <body>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/objects/Sky.js"></script>
    <script>
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      // 상수 정의
      const DRONE_COUNT = 200;
      const DRONE_START_DELAY = 150; // 드론 출발 간격
      const FORMATION_TIME = 3000; // 형성 시간
      const HOLD_TIME = 5000; // 유지 시간
      const SCATTER_TIME = 2000; // 흩어지는 시간
      const START_POSITION = { x: 50, y: 30, z: 50 }; // 시작 위치

      // Sky 설정
      const sky = new THREE.Sky();
      sky.scale.setScalar(450000);
      scene.add(sky);

      const uniforms = sky.material.uniforms;
      uniforms["turbidity"].value = 10;
      uniforms["rayleigh"].value = 3;
      uniforms["mieCoefficient"].value = 0.005;
      uniforms["mieDirectionalG"].value = 0.7;

      const sun = new THREE.Vector3();
      const phi = THREE.MathUtils.degToRad(90 - 2);
      const theta = THREE.MathUtils.degToRad(180);
      sun.setFromSphericalCoords(1, phi, theta);
      uniforms["sunPosition"].value.copy(sun);

      // 상태 관리
      const FormationState = {
        INITIAL: "INITIAL", // 초기 상태
        LAUNCHING: "LAUNCHING", // 드론 출발
        STAR: "STAR", // 별 형성
        HOLDING: "HOLDING", // 별 유지
        SCATTER: "SCATTER", // 흩어짐
        TEXT: "TEXT", // 텍스트 형성
      };

      let currentState = FormationState.INITIAL;
      let stateStartTime = 0;

      // 드론 생성 함수
      function createDrone(index) {
        const droneGroup = new THREE.Group();

        const bodyGeometry = new THREE.BoxGeometry(0.4, 0.08, 0.4);
        const bodyMaterial = new THREE.MeshPhysicalMaterial({
          color: 0x2c3e50,
          metalness: 0.7,
          roughness: 0.3,
          clearcoat: 0.5,
          clearcoatRoughness: 0.3,
        });
        const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
        droneGroup.add(body);

        const armGeometry = new THREE.BoxGeometry(0.08, 0.04, 1.0);
        const armMaterial = new THREE.MeshPhysicalMaterial({ color: 0x34495e });

        const arm1 = new THREE.Mesh(armGeometry, armMaterial);
        const arm2 = new THREE.Mesh(armGeometry, armMaterial);
        arm1.rotation.y = Math.PI / 4;
        arm2.rotation.y = -Math.PI / 4;
        droneGroup.add(arm1);
        droneGroup.add(arm2);

        const propellerGeometry = new THREE.BoxGeometry(0.04, 0.01, 0.3);
        const propellerMaterial = new THREE.MeshPhysicalMaterial({
          color: 0x95a5a6,
        });

        [
          { x: 0.35, z: 0.35 },
          { x: -0.35, z: 0.35 },
          { x: 0.35, z: -0.35 },
          { x: -0.35, z: -0.35 },
        ].forEach((pos) => {
          const propeller = new THREE.Mesh(
            propellerGeometry,
            propellerMaterial
          );
          propeller.position.set(pos.x, 0.08, pos.z);
          droneGroup.add(propeller);
        });

        // 초기 위치 설정: 오른쪽 구석에서 일렬로 정렬
        droneGroup.position.set(
          START_POSITION.x,
          START_POSITION.y - index * 0.5,
          START_POSITION.z + index * 0.5
        );

        scene.add(droneGroup);
        return droneGroup;
      }

      // 별 모양 포인트 생성
      function createStarPoints() {
        const points = [];
        const starRadius = 20;
        const pointsPerArm = Math.floor(DRONE_COUNT / 5);

        for (let arm = 0; arm < 5; arm++) {
          const armAngle = (arm / 5) * Math.PI * 2;
          for (let i = 0; i < pointsPerArm; i++) {
            const t = i / pointsPerArm;
            const radius = starRadius * (i % 2 === 0 ? 1 : 0.5);
            points.push({
              x: Math.cos(armAngle) * radius * t,
              y: Math.sin(armAngle) * radius * t + 15,
              z: 0,
            });
          }
        }
        return points;
      }

      // 흩어지는 포인트 생성
      function createScatterPoints(count) {
        return Array(count)
          .fill()
          .map(() => ({
            x: (Math.random() - 0.5) * 80,
            y: Math.random() * 40 + 10,
            z: (Math.random() - 0.5) * 80,
          }));
      }

      // Nation A 텍스트 포인트 생성
      function createTextPoints() {
        const points = [];
        const letterSpacing = 12;
        const letterHeight = 15;
        const smallLetterHeight = letterHeight * 0.5;
        let currentX = -40;

        // N
        for (let i = 0; i < 30; i++) {
          const t = i / 29;
          points.push({ x: currentX, y: t * letterHeight, z: 0 });
          points.push({ x: currentX + t * 4, y: t * letterHeight, z: 0 });
          points.push({ x: currentX + 4, y: t * letterHeight, z: 0 });
        }
        currentX += letterSpacing;

        // ation
        // ... [이전 코드의 나머지 글자 생성 로직]

        return points;
      }

      // 드론과 포인트 생성
      const drones = Array(DRONE_COUNT)
        .fill()
        .map((_, i) => createDrone(i));
      const starPoints = createStarPoints();
      const scatterPoints = createScatterPoints(DRONE_COUNT);
      const textPoints = createTextPoints();

      // 드론 상태 초기화
      let droneStates = drones.map((_, index) => ({
        isMoving: false,
        progress: 0,
        startTime: index * DRONE_START_DELAY,
        arrived: false,
      }));

      // 물결 효과 색상
      const waveColors = [
        0xff0000, 0xff7f00, 0xffff00, 0x00ff00, 0x0000ff, 0x4b0082, 0x9400d3,
      ];

      let lastTime = 0;
      let propellerRotation = 0;
      let globalTime = 0;

      function updateFormationState(currentTime) {
        const totalLaunchTime = DRONE_COUNT * DRONE_START_DELAY;

        if (currentState === FormationState.INITIAL && currentTime > 1000) {
          currentState = FormationState.LAUNCHING;
          stateStartTime = currentTime;
        } else if (
          currentState === FormationState.LAUNCHING &&
          currentTime - stateStartTime > totalLaunchTime + FORMATION_TIME
        ) {
          currentState = FormationState.STAR;
          stateStartTime = currentTime;
        } else if (
          currentState === FormationState.STAR &&
          currentTime - stateStartTime > HOLD_TIME
        ) {
          currentState = FormationState.SCATTER;
          stateStartTime = currentTime;
        } else if (
          currentState === FormationState.SCATTER &&
          currentTime - stateStartTime > SCATTER_TIME
        ) {
          currentState = FormationState.TEXT;
          stateStartTime = currentTime;
        }
      }

      function animate(currentTime) {
        requestAnimationFrame(animate);

        const deltaTime = lastTime ? currentTime - lastTime : 0;
        lastTime = currentTime;
        globalTime += deltaTime * 0.001;

        updateFormationState(currentTime);

        // 프로펠러 회전
        propellerRotation += deltaTime * 0.01;
        drones.forEach((drone) => {
          drone.children.slice(3).forEach((propeller) => {
            propeller.rotation.y = propellerRotation;
          });
        });

        // 드론 이동 업데이트
        drones.forEach((drone, index) => {
          let targetPoint;
          let progress;

          switch (currentState) {
            case FormationState.INITIAL:
              return;

            case FormationState.LAUNCHING:
            case FormationState.STAR:
              targetPoint = starPoints[index];
              progress =
                Math.max(0, currentTime - droneStates[index].startTime) /
                FORMATION_TIME;
              break;

            case FormationState.SCATTER:
              targetPoint = scatterPoints[index];
              progress = (currentTime - stateStartTime) / SCATTER_TIME;
              break;

            case FormationState.TEXT:
              targetPoint = textPoints[index % textPoints.length];
              progress = (currentTime - stateStartTime) / FORMATION_TIME;
              if (progress >= 1) {
                const wavePhase = globalTime * 2 + index * 0.1;
                const colorIndex =
                  Math.floor((Math.sin(wavePhase) + 1) * 3.5) %
                  waveColors.length;
                drone.children[0].material.color.setHex(waveColors[colorIndex]);
              }
              break;
          }

          progress = Math.min(1, Math.max(0, progress));

          const startPos = drone.position.clone();
          const controlPoint = {
            x: (startPos.x + targetPoint.x) / 2,
            y: Math.max(startPos.y, targetPoint.y) + 10,
            z: (startPos.z + targetPoint.z) / 2,
          };

          // 베지어 곡선 이동
          const t = progress;
          const mt = 1 - t;
          drone.position.x =
            mt * mt * startPos.x +
            2 * mt * t * controlPoint.x +
            t * t * targetPoint.x;
          drone.position.y =
            mt * mt * startPos.y +
            2 * mt * t * controlPoint.y +
            t * t * targetPoint.y;
          drone.position.z =
            mt * mt * startPos.z +
            2 * mt * t * controlPoint.z +
            t * t * targetPoint.z;
        });

        controls.update();
        renderer.render(scene, camera);
      }

      // OrbitControls 설정
      const controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.screenSpacePanning = false;
      controls.minDistance = 10;
      controls.maxDistance = 200;

      // 카메라 및 조명 설정
      camera.position.set(0, 30, 80);
      camera.lookAt(0, 15, 0);

      const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
      scene.add(ambientLight);

      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(10, 10, 10);
      scene.add(directionalLight);

      animate(0);

      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    </script>
  </body>
</html>
